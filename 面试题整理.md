## 面试题

1. 生命周期

   - beforeCreate：刚把vue实例创建完，data & methods 都没有创建
   - created：data & methods 创建好了，模版还没有编译
   - beforeMount：完成了模版的编译，但是还没有挂载到页面上
   - mounted：编译后的模版挂载到页面中，页面也完成了渲染
   - beforeUpdate：data数据的状态值已经更新，但是页面未完成渲染
   - updated：页面完成了渲染
   - beforeDestroy：vue实例销毁之前，在这可以访问vue实例的所有属性
   - destroy：vue实例已经被销毁

2. 父组件 子组件生命周期顺序

   - 父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted
   - 父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
   - 父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed

3. nextTick
   在下次 DOM 更新循环结束之后执行延迟回调。
   Vue在更新DOM时是异步执行的。当数据发生变化，Vue将开启一个一步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新。

4. 组件通讯

   - 通过props传递
   - 使用$emit触发自定义事件
   - 使用ref
   - EventBus
   - $parent 或 $root
   - attires 与 listeners
   - Provide 与 Inject
   - Vuex

5. vuex
   全局状态管理器

   - state用来存放共享变量
   - mutations用来存放修改state的方法
   - actions用于一些异步操作

6. vuex刷新的时候数据丢失怎么解决
   存储于本地，刷新之后获取

7. 验证用户是否登陆

   用户登录 - 服务器下发 token - 前端存储 token 到 cookies

   前端发送请求（携带cookie）- 服务器 验证 cookie - 用户身份合法 - 返回信息
   或者 用户身份不合法 - 返回错误代码 - 前端 清除cookie - 提示用户登录已过期，请重新登录

8. 路由模式区别

   - hash 由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件，浏览器的进后退也能对其进行控制，所以人们在 html5 的 history 出现前，基本都是使用 hash 来实现前端路由的。
   - history 的原理 略微复杂一点，它可以通过history.pushState(state, title, url)去变动url 内容， 不会造成页面刷新。这里state 可以存一些params值。url 就是要变动的url。既然浏览器不会刷新。那么和hash 就变成一样的效果了, 但是比hash美观。

9. v-if 和 v-show 的区别

   - v-if 每次切换都是重新渲染和销毁
   - v-show 显示隐藏是基于css的样式切换，display

10. computed 和 watch

    - computed
    - watch

11. async 和 await 语法糖
    async/await 是以更舒适的方式使用 promise 的一种特殊语法，同时它也非常易于理解和使用。（以同步的方式执行异步的代码）

12. promise

13. ajax发送请求的步骤

    1. 建立 XMLHttpRequest 对象
    2. 设置回调函数
    3. 配置请求信息，使用 open 方法与服务器建立连接
    4. 向服务器发送数据
    5. 在回调函数中针对不同的响应状态进行处理

14. 怎么改变this的指向

    1. bind 不调用函数，参数以列表方式传递
    2. call 调用函数，参数以列表方式传递
    3. apply 调用函数，参数以数组方式传递

15. 跨域怎么解决

    1. CORS cross-origin resource sharing 配置请求头 Access-Control-Allow-Origin
    2. JSONP：与服务端约定好一个回调函数名，服务端接收到请求后，将返回一段 Javascript，在这段  Javascript 代码中调用了约定好的回调函数，并且将数据作为参数进行传递。当网页接收到这段 Javascript 代码后，就会执行这个回调函数，这时数据已经成功传输到客户端了。
    3. proxy：使用代理服务器

16. 深拷贝、浅拷贝

    - 深拷贝 复制了一个一摸一样的对象出来。1. 使用 JSON.stringify 再 parse; 2.递归实现
    - 浅拷贝 拷贝了引用类型的地址。

17. 插槽slot的实现原理,插件的实现原理

18. 闭包
    一个函数对其周围状态的引用捆绑在一起的组合叫闭包。
    作用：1.私有制变量 2.延长变量的生命周期

    > 一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的

19. 防抖节流

20. 原型和原型链
    四个概念

    1. js分为**函数对**象和**普通对象**，每个对象都有`__proto__`属性，但是只有函数对象才有`prototype`属性
    2. Object、Function都是js内置的**函数**, 类似的还有我们常用到的Array、RegExp、Date、Boolean、Number、String
    3. 属性`__proto__`是一个对象，它有两个属性，`constructor`和`__proto__`；
    4. 原型对象`prototype`有一个默认的`constructor`属性，用于记录实例是由哪个构造函数创建；

    准则：a. 原型对象的constructor指向构造函数本身; b.实例的`__proto__`和原型对象指向同一个地方

21. 首屏加载优化

    1. 静态资源压缩
    2. cdn加载
    3. 减少回流重绘
    4. 避免css、js的阻塞，先加载css再加载js
    5. 内联首屏关键css

22. css优化

    1. 异步加载css
    2. 减少文件体积
    3. 去除无用css
    4. 有效地使用选择器（避免过多的嵌套）
    5. 减少昂贵的属性
    6. 优化回流重绘
    7. 减少@import引入css。影响并行下载

23. es6新特性

    - 箭头函数
    - 解构赋值
    - promise
    - async / await
    - proxy
    - symbol

24. uniapp 和 vue 的区别

25. 前端项目部署之后跨域问题

26. js 的基本数据类型

    - String
    - Number
    - Boolean
    - Undefined
    - Null
    - Symbol

27. js 的浮点数失真问题

    ![二进制小数](https://www.runoob.com/wp-content/uploads/2018/11/210-3.png)

    

    `Number`采用的是`IEEE754`规范中64位双精度浮点数编码。这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。

    - 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
    - 指数位E：中间的 11 位存储指数（exponent），用来表示次方数
    - 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

28. undefined 和 null 的区别

    - Undefined类型只有一个值 特殊值 `undefined`。当声明了变量但没有初始化的时候，就相当于给变量赋予了 `undefined`值。
    - Null类型只有一个值 特殊值`null`。 null值表示一个空对象指针。

29. 本地存储的方式

    - cookie 

      生命周期：设置过期时间之前一直有效。
      每次发送请求的时候都会发送cookie。
      `Document.cookie` API 无法访问带有 `HttpOnly` 属性的cookie。

    - sessionStorage
      生命周期：页面（会话）内有效，当关闭页面的时候数据就会被清除。

    - localStorage 
      生命周期：只有主动删除数据才会被清除，永不过期。
      作用域：存储的信息在同一域中是共享的
      受同源策略的限制

30. 熟悉的ui框架

31. uniapp的跳转方式

32. uniapp底部导航栏配置

33. vuex vue-router动态权限的控制

    1. 配置全部的前端路由列表，并加上用于判断的meta字段
    2. 获取后端的信息进行对比筛选，使用  `addRoutes()` 动态添加进路由

34. HTML5语义化
    使用一些有意义的次来代替`<div>`标签。从而使代码更加有结构，有意义。

    语义化的优点：

    - 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。
    - 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。
    - 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。
    - 方便其他设备解析，如盲人阅读器根据语义渲染网页

35. viewport
    视口当前可见的部分叫做 **可视视口(visual viewport)** 。

36. meta viewport
    提供有关视口初始大小的提醒。

37. css盒模型

    1. 标准盒模型(content-box)，width 只包括 content。
    2. 怪异盒模型(border-box)，width 包括 content、padding、boder。

38. css选择器优先级
    在给页面元素设置样式的时候，如果同时有多个css选择器同时指向一个元素，那么优先级高的选择器的元素样式最终会应用到这个元素上。

    ![image.png](/Users/zhangjiawei/Desktop/css优先级.jpg)

    - `!important`权重最高
    - 权重相同，靠后定义的样式会覆盖前面定义的样式。

39. css元素百分比单位计算方式

    1. font-size: 如果父元素没有显式的设置`font-size`则取浏览器默认值`16px`来计算，如果有则根据父元素`font-size`计算；
    2. line-height: 根据 `font-size` 的大小计算；
    3. width / height: 1. 当 `position` 不是 `absolute | fixed`  的时候，根据**父元素**的`宽高(content)`来计算；2. 当`position` 为 `absolute | fixed` 的时候，根据**位置参照元素**的`计算宽高(border + padding + content)`；
    4. padding / margin: 1. 当 `position` 不是 `absolute | fixed`  的时候，根据**父元素** `宽(content-width)` 来计算； 2. 当`position` 为 `absolute | fixed` 的时候，**位置参照元素**的`计算宽度(padding-left + padding-right + content-width)`；
    5. border-radius: 根据**元素自身**的`计算宽高(border + padding + content)`来计算；
    6. top / right / bottom / left: 根据**位置参照元素**的宽高计算；
    7. transform: 根据**元素自身**`计算宽高(padding + content)`计算；

40. rem和em的区别

    - em: 在 `font-size` 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width
    - rem: 根元素的字体大小

41. vue的双向数据绑定
    vue的双向绑定其实是一个语法糖，`v-modal`会自动给标签加上`input`事件监听，而事件内部修改所绑定的data。
    双向绑定也涉及到vue的响应式。vue的响应式主要是用了`Object.defineProperty` 和 `订阅 - 发布模式` 。

    - 简单的双向绑定：使用 `Object.defineProperty` 进行数据的拦截，拦截 `setter` 对页面更新。
    - 双向绑定的原理：1. `Object.defineProperty`数据拦截； 2. 发布者 - 订阅者模式。

42. vue生命周期的熟练度

    - beforeCreate：Vue实例刚创建完成，Data 和 Method 还没有完成初始化
    - created：Data 和 Method 完成初始化。模版还没开始编译。
    - beforeMount：模版完成了编译，但是没有挂载到页面上。可以获取$el。
    - mounted：模版挂载到页面上了，可以获取到 DOM 节点。
    - beforeUpdate：Data 已经更新，页面未完成更新。
    - updated： 完成了页面更新。
    - beforeDestroy：Vue实例摧毁之前，可以访问到所有的属性。
    - destroy：Vue实例摧毁

43. vue2 对象 和 数组不响应式怎么办

    - 对于对象
      1. 使用 `vm.$set` 或 `Vue.set`
      2. 使用 `Object.assign()`，并赋值给原对象
    - 对于数组
      1. 使用 `vm.$set` 或 `Vue.set`
      2. 使用 `splice` 解决长度问题

44. 为什么data返回一个对象而不是直接写成一个对象
    当复用组件的时候，数据对象都指向同一个 data 对象，当在一个组件中修改数据的时候，其他复用的组件中的 data 会同时被修改；而使用返回一个对象的方式，则每个组件返回的都是一个新对象，引用地址不同。

45. vuex 为什么异步要用actions 而不能直接用 mutation

46. js原型和原型链

47. 改变this指针的方法

48. 说一下箭头函数

49. 围绕this指针箭头函数有什么特殊性

50. 数组去重

51. js的基本数据类型 和 引用数据类型

52. 说一下 symbol，主要用于什么

53. 深拷贝 和 浅拷贝

54. 深拷贝方式

55. JSON方式深拷贝有什么劣势

    - 当属性有 Date 对象时，序列化变成字符串；
    - 当属性有 RegExp、Error 对象时，序列化变成空对象；
    - 当属性里有 function、undefined 序列化会丢失；
    - 当属性里有 NaN、Infinity、-Infinity，序列化会变成null；
    - 当属性里有 new 出来的对象，对象的构造函数会丢失；

56. 为什么会出现跨域

57. JSONP的原理

58. vue 和 react 有什么不同

59. 虚拟DOM的优势

60. v-for使用key

61. diff算法

62. 事件委托

63. 适配机型注意的事项

64. 滚动事件穿透怎么解决

65. vue项目做过优化吗？

66. webpack做过优化吗？

67. 小程序开发有做优化吗？

68. 解构赋值

69. 扩展运算符

70. 说一下 `for...of` 和 `for...in`

71. 说一下vue路由

72. 路由传参数的方式

73. 你有用过路由守卫吗

74. 路由守卫的三个参数

75. vuex的几种状态

76. HTTP/1.0  HTTP/1.1 和 HTTP/2.0

77. HTTP的缓存机制

78. react 和 vue 的区别

79. vue diff算法

80. vue 的 getter 和 setter 具体干了什么

81. js 的闭包

82. js 的作用域
    作用域一般分为：

    - 全局作用域
      任何不在函数中或是打括号中生命的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。
    - 函数作用域
      函数作用域也叫做局部作用域。
    - 块级作用域
      ES6引入了 `let` 和 `const` 关键字，和 `var` 关键字不同，在打括号中使用 `let` 和 `const` 声明的变量存在于块级作用域中。在打括号外不能访问这些变量。

    词法作用域：

    - 又称作静态作用域，变量被创建时就确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就确定了，`Javascript`遵循的就是词法作用域。

    作用域链：

    - 当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。

83. js 的继承

84. js 的内存管理

85. js 的垃圾回收

86. js 的事件循环

87. Js 的原型和原型链

88. 重绘重排





## 待整理内容

### ES6

#### Babel转码器



#### 变量声明

- 块级作用域
- 暂时性死区（TDZ）
- 顶层对象
- IIFE



#### 结构赋值

- iterator遍历器 `obj[Symbol.iterator]`



#### 扩展运算符